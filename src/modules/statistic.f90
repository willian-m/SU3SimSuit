!Willian Matioli Serenone
!Institution: Universidade de Sao Paulo
!             Instituto de Fisica de Sao Carlos
!e-mail: willian.serenone@usp.br
!######################################################################


!==============================
!MODULE: statistic
!We compute averages, correlation times, etc
!==============================

include "mkl_dfti.f90"

module statistic
    use types_params
    use MKL_DFTI !This article may be usefull at
    !understanding how to use these libraries
    !https://software.intel.com/en-us/articles/the-intel-math-kernel-library-and-its-fast-fourier-transform-routines
    implicit none

    private
    public average_real,average_complex
    public correlation_real,connected_correlation_real,corr_time_int

    contains

    !==============================
    !Performs the usual average of a real ensemble of numbers
    real(dp) function average_real(input_data)
        real(dp), intent(in) :: input_data(:)
        integer :: n,i

        average_real = 0.0_dp
        n=size(input_data)
        do i=1,n
            average_real = average_real + input_data(i)
        end do
        average_real = average_real/n
    
    end function average_real
    !==============================

    !==============================
    !Performs the usual average of a complex ensemble of numbers
    complex(dp) function average_complex(input_data)
        complex(dp), intent(in) :: input_data(:)
        integer :: n,i

        average_complex = 0.0_dp
        n=size(input_data)
        do i=1,n
            average_complex = average_complex + input_data(i)
        end do
        average_complex = average_complex/n
    
    end function average_complex

    !==============================
    !Computes the usual autocorrelation between real numbers generated by a MC sequence
    !This uses the property that C_{a b}(j) = InverseFourier[a(w)a(-w),j]/N,
    !where a(w) = Fourier[a(x),w] and a(x) is the data
    subroutine correlation_real(input_data, corr)
        real(dp), intent(in) :: input_data(:)
        complex(dp), allocatable :: out_DFT(:)
        real(dp), intent(out), allocatable :: corr(:)
        integer :: n,i,stat
        type(DFTI_DESCRIPTOR), pointer :: descHandler

        !Get the size of the data
        n=size(input_data)
        
        !Check if data has even number of points. If not, throw the last point away.
        if (mod(n,2) .ne. 0) then 
            n = n-1
        end if
        
        !Allocate vector used on FFT computations
        allocate(out_DFT(n/2 + 1))
        allocate(corr(n))
        !allocate(inp_back_FFT(n))

        !We need to create a DESCRIPTOR to describe the parameters of the transform
        stat = DftiCreateDescriptor( descHandler, DFTI_DOUBLE, DFTI_REAL, 1, n )
        stat = DftiSetValue( descHandler, DFTI_FORWARD_SCALE, 1.0_dp)
        stat = DftiSetValue( descHandler, DFTI_BACKWARD_SCALE, 1.0_dp/two_pi)
        !We do not desire to overwrite the input data
        stat = DftiSetValue( descHandler, DFTI_PLACEMENT, DFTI_NOT_INPLACE)
        !Set up the layout of the output
        stat = DftiSetValue( descHandler, DFTI_CONJUGATE_EVEN_STORAGE, DFTI_COMPLEX_COMPLEX)
        stat = DftiSetValue( descHandler, DFTI_PACKED_FORMAT, DFTI_CCE_FORMAT)
        !Commit descriptor!
        stat = DftiCommitDescriptor( descHandler )

        !Compute FFT
        !Need to use slice, in case we are thowing away the last point
        stat = DftiComputeForward( descHandler, input_data(1:n), out_DFT)

        !Prepares the input of the backward transform
        !inp_back_FFT(1) = out_DFT(1)**2 !First element is real
        do i=1,n/2+1
            out_DFT(i) = out_DFT(i)*conjg(out_DFT(i))
!            inp_back_FFT(i) = real(out_DFT(i)*conjg(out_DFT(i)))
!            inp_back_FFT(n+2-i) = inp_back_FFT(i)
        end do

        !We can use the same descriptor, since the input is on the same shape
        stat = DftiComputeBackward( descHandler, out_DFT, corr)

        !Normalizes the correlation
        corr = corr/n

        !Clean up
        stat = DftiFreeDescriptor( descHandler )
        deallocate(out_DFT)
    
    end subroutine correlation_real
    !==============================

    !==============================
    !Computes the usual connected autocorrelation between real numbers generated by a MC sequence
    !This uses the property that C_{a b}(j) = InverseFourier[a(w)a(-w),j]/N,
    !where a(w) = Fourier[a(x),w] and a(x) is the data
    subroutine connected_correlation_real(input_data, corr)
        real(dp), intent(in) :: input_data(:)
        complex(dp), allocatable :: out_DFT(:)
        real(dp), intent(out) :: corr(:)
        integer :: n,i,stat
        real(dp) :: avrg
        type(DFTI_DESCRIPTOR), pointer :: descHandler

        !Get the size of the data
        n=size(input_data)
        
        !Check if data has even number of points. If not, throw the last point away.
        if (mod(n,2) .ne. 0) then 
            n = n-1
        end if
        
        !Allocate vector used on FFT computations
        allocate(out_DFT(n/2 + 1))
        !allocate(inp_back_FFT(n))

        !We need to create a DESCRIPTOR to describe the parameters of the transform
        stat = DftiCreateDescriptor( descHandler, DFTI_DOUBLE, DFTI_REAL, 1, n )
        stat = DftiSetValue( descHandler, DFTI_FORWARD_SCALE, 1.0_dp)
        stat = DftiSetValue( descHandler, DFTI_BACKWARD_SCALE, 1.0_dp/two_pi)
        !We do not desire to overwrite the input data
        stat = DftiSetValue( descHandler, DFTI_PLACEMENT, DFTI_NOT_INPLACE)
        !Set up the layout of the output
        stat = DftiSetValue( descHandler, DFTI_CONJUGATE_EVEN_STORAGE, DFTI_COMPLEX_COMPLEX)
        stat = DftiSetValue( descHandler, DFTI_PACKED_FORMAT, DFTI_CCE_FORMAT)
        !Commit descriptor!
        stat = DftiCommitDescriptor( descHandler )

        !Compute FFT
        !Need to use slice, in case we are thowing away the last point
        stat = DftiComputeForward( descHandler, input_data(1:n), out_DFT)

        avrg = out_DFT(1)/n
        do i=1,n/2+1
            out_DFT(i) = out_DFT(i)*conjg(out_DFT(i))
        end do

        !We can use the same descriptor, since the input is on the same shape
        stat = DftiComputeBackward( descHandler, out_DFT, corr)

        !Normalizes the correlation
        do i=1,n
            corr(i) = corr(i)/n - avrg**2 
        end do

        !Clean up
        stat = DftiFreeDescriptor( descHandler )
        deallocate(out_DFT)
    
    end subroutine connected_correlation_real
    !==============================

    !==============================
    !Given a correlation function, computes its integrated correlation time
    !Implements automatic windowing algorithm
    integer recursive function corr_time_int(corr,m) result(tau)
    integer, intent(in) :: m !Initial window
    real(dp), intent(in) :: corr(:)
    integer :: n, i

    n = size(corr)
    tau = 1
    if (m .le. n) then
        do i=2,m
            tau = tau + 2*(1 - real(i-1)/real(N))*corr(i)/corr(1)
        end do
    end if

    if (m .lt. 10*tau ) then
        tau = corr_time_int(corr,m+1) !If the test fails, we 
                                      !are not in a big enough window. Increase it.
    end if

    end function corr_time_int

end module
